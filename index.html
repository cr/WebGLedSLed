<!doctype html>
<html>

<head>
<title>WebGLEd</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">


<!-- Vertex shader -->

<script id="shader-vs" type="x-shader/x-vertex">
precision highp float;
attribute vec3 vert;
varying vec2 pos;
void main(void) {
  pos = vert.xy*vec2(0.5)+vec2(0.5);
  gl_Position = vec4( vert.xy, 0.0, 1.0 );
}
</script>

<!-- Fragment shader -->

<script id="shader-fs" type="x-shader/x-fragment">
precision highp float;
uniform float t; // time
varying vec2 pos; // relative position on quad
void main( void ) {
  vec4 color = vec4(
    abs( sin( t / 11.3 ) ) * pos.x,
    abs( sin( t / 9.7 ) ) * pos.y,
    1.0 - abs( cos( t / 8.3 ) ),
    1.0
  );
  gl_FragColor = color;
}
</script>


<script type="text/javascript">
"use strict";

var canvas;
var gl;
var shaderProgram;
var vertexPositionAttribute;
var quadBuffer;
var timeUniform;

var Timer = {
    started_at: Date.now(),
    reset: function() { this.started_at = Date.now(); },
    now: function() { return (Date.now()-this.started_at)/1000.0; },
}

function start() {
  canvas = document.getElementById( "glcanvas" );
  gl = initWebGL( canvas );      // Initialize the GL context
  if (gl) {
    gl.clearColor( 0.0, 0.0, 0.0, 1.0 );  // Set clear color, fully opaque
    gl.clearDepth( 1.0 );                 // Clear everything
    //gl.enable( gl.DEPTH_TEST );           // Enable depth testing
    //gl.depthFunc( gl.LEQUAL );            // Near things obscure far things
    initShaders();
    initBuffers();
    onWindowResize();
    window.addEventListener( 'resize', onWindowResize, false );
    setInterval( render, 1/60.0*1000 );
  }
}

function onWindowResize( event ) {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;

  //arameters.screenWidth = canvas.width;
  //parameters.screenHeight = canvas.height;

  //parameters.aspectX = canvas.width/canvas.height ;
  //parameters.aspectY = 1.0 ;

  gl.viewport( 0, 0, canvas.width, canvas.height );
}

function initWebGL( canvas ) {
  var gl = null;
  try {
    gl = canvas.getContext( "experimental-webgl" );
    gl.viewportWidth = canvas.width;
    gl.viewportHeight = canvas.height;
  } catch( e ) {
  }
  if( !gl ) {
    alert( "Unable to initialize WebGL" );
  }
  return gl;
}

function render() {
  gl.clear( gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT );

  gl.uniform1f( timeUniform, Timer.now() );

  gl.bindBuffer( gl.ARRAY_BUFFER, quadBuffer );
  gl.vertexAttribPointer( vertexPositionAttribute, 3, gl.FLOAT, false, 0, 0 );

  gl.drawArrays( gl.TRIANGLE_STRIP, 0, 4 );
}

function initShaders() {
  var fragmentShader = getShader( gl, "shader-fs" );
  var vertexShader = getShader( gl, "shader-vs" );
  
  // Create the shader program
  shaderProgram = gl.createProgram();
  gl.attachShader( shaderProgram, vertexShader );
  gl.attachShader( shaderProgram, fragmentShader );
  gl.linkProgram( shaderProgram );
  
  // If creating the shader program failed, alert
  if( !gl.getProgramParameter( shaderProgram, gl.LINK_STATUS ) ) {
    alert( "Unable to initialize the shader program" );
  }
  
  gl.useProgram( shaderProgram );

  timeUniform = gl.getUniformLocation( shaderProgram, 't' );
  
  vertexPositionAttribute = gl.getAttribLocation( shaderProgram, "vert" );
  gl.enableVertexAttribArray( vertexPositionAttribute );
  
}

function getShader( gl, id ) {
  var shaderScript = document.getElementById( id );
  
  // Didn't find an element with the specified ID; abort.
  if( !shaderScript ) {
    return null;
  }
  
  // Walk through the source element's children, building the
  // shader source string.  
  var theSource = "";
  var currentChild = shaderScript.firstChild;
  while( currentChild ) {
    if( currentChild.nodeType == 3 ) {
      theSource += currentChild.textContent;
    }
    currentChild = currentChild.nextSibling;
  }
  //console.log(theSource);
  // Construct shader according to script's MIME type
  var shader;
  if( shaderScript.type == "x-shader/x-fragment" ) {
    shader = gl.createShader( gl.FRAGMENT_SHADER );
  } else if( shaderScript.type == "x-shader/x-vertex" ) {
    shader = gl.createShader( gl.VERTEX_SHADER );
  } else {
    return null;  // Unknown shader type
  }
  
  gl.shaderSource( shader, theSource );
  gl.compileShader( shader );
  
  // Check for compile errors  
  if( !gl.getShaderParameter( shader, gl.COMPILE_STATUS ) ) {
    alert( "An error occurred compiling the shaders: " + gl.getShaderInfoLog( shader ) + "\n\nERROR: " + gl.getError()  );
    return null;
  }
  
  return shader;
}

function initBuffers() {
  var quad = [
     1.0,  1.0, 0.0,
    -1.0,  1.0, 0.0,
     1.0, -1.0, 0.0,
    -1.0, -1.0, 0.0
  ];
  quadBuffer = gl.createBuffer();
  gl.bindBuffer( gl.ARRAY_BUFFER, quadBuffer );
  gl.bufferData( gl.ARRAY_BUFFER, new Float32Array( quad ), gl.STATIC_DRAW );
}

</script>

<style type="text/css">
html, body {
  margin: 0px;
}
#glcanvas {
  width: 100%;
  height: 100%;
  background-color: white;
}
#editor {
  position: absolute;
  top: 0px;
  width: 100%;
  height: 100%;
  color: #889988;
  font-family: Monospace;
  font-size: 14px;
  font-weight: bold;
  text-shadow: rgba( 0, 0, 0, 0.75 ) 0px 1px 2px;
  background-color: rgba(0,0,0,0.4);
  padding: 1em;
  visibility: hidden;
}

</style>

</head>

<body onload="start()">
  <canvas id="glcanvas" width="640" height="480">No HTML5 canvas support in the browser</canvas>
  <div id="editor"></div>
</body>

</html>
