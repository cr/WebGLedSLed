<!doctype html>
<html>

<head>
<title>GLedSLed</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">


<!-- Vertex shader -->

<script id="shader-vs" type="x-shader/x-vertex">
precision highp float;
attribute vec3 vert;
varying vec2 pos;
void main(void) {
  pos = vert.xy*vec2(0.5)+vec2(0.5);
  gl_Position = vec4( vert.xy, 0.0, 1.0 );
}
</script>

<!-- Fragment shader -->

<script id="shader-fs" type="x-shader/x-fragment">
precision highp float;
uniform float t; // time
varying vec2 pos; // relative position on quad

void main( void ) {
  vec4 color = vec4(
    abs( sin( t / 11.3 ) ) * pos.x,
    abs( sin( t / 9.7 ) ) * pos.y,
    1.0 - abs( cos( t / 8.3 ) ),
    1.0
  );
  gl_FragColor = color;
}
</script>


<script type="text/javascript">
"use strict";

var canvas;
var gl;
var shaderProgram;
var vertexPositionAttribute;
var quadBuffer;
var timeUniform;

function start() {

  editor = document.getElementById( "editor" );
  editor.textContent = shaderString( "shader-fs" );

  canvas = document.getElementById( "glcanvas" );
  gl = initWebGL( canvas );      // Initialize the GL context
  if (gl) {
    gl.clearColor( 0.0, 0.0, 0.0, 1.0 );  // Set clear color, fully opaque
    gl.clearDepth( 1.0 );                 // Clear everything
    //gl.enable( gl.DEPTH_TEST );           // Enable depth testing
    //gl.depthFunc( gl.LEQUAL );            // Near things obscure far things
    initShaders();
    initBuffers();
    onWindowResize();
    window.addEventListener( "resize", onWindowResize, false );
    document.addEventListener( "keydown", onKeys, false );
    document.getElementById( 'editor' ).focus();
    tick();
  }
}

function tick( t ) {
    render( t );
    requestAnimationFrame( tick );
}

function onKeys( e ) {
  if( e.keyCode == 9 || e.which == 9 ) return false; // ignore tabs
  switch( e.keyCode ) {
    case 32: if( e.ctrlKey ) toggleEditor(); break; // on ctrl+space
    case 13: if( e.ctrlKey ) useCurrentShader(); break; // on ctrl+return
    case 27: if( e.ctrlKey ) toggleFullscreen(); break; // on ctrl+esc
  }
}

function toggleEditor() {
  var editor = document.getElementById( "editor" );
  if( editor.style.visibility == "hidden" ) {
    editor.style.visibility = "";
    editor.focus();
  } else {
    editor.style.visibility = "hidden";
  }
}

function useCurrentShader() {
  var vertexShader = getShader( gl, "shader-vs" );

  var fragmentShaderStr = shaderString( "editor" );
  var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER ); 
  gl.shaderSource( fragmentShader, fragmentShaderStr );
  gl.compileShader( fragmentShader );
  
  // Check for compile errors  
  if( !gl.getShaderParameter( fragmentShader, gl.COMPILE_STATUS ) ) {
    alert( "Shader compilation failed:\n\n" + gl.getShaderInfoLog( fragmentShader ) );
    return;
  }
 
  // Create the shader program
  shaderProgram = gl.createProgram();
  gl.attachShader( shaderProgram, vertexShader );
  gl.attachShader( shaderProgram, fragmentShader );
  gl.linkProgram( shaderProgram );
  
  // If creating the shader program failed, alert
  if( !gl.getProgramParameter( shaderProgram, gl.LINK_STATUS ) ) {
    alert( "Unable to initialize the shader program" );
    return;
  }
  
  gl.useProgram( shaderProgram );

  timeUniform = gl.getUniformLocation( shaderProgram, 't' );
  
  vertexPositionAttribute = gl.getAttribLocation( shaderProgram, "vert" );
  gl.enableVertexAttribArray( vertexPositionAttribute );
}

function toggleFullscreen() {
  if (!document.fullscreenElement &&    // alternative standard method
      !document.mozFullScreenElement && !document.webkitFullscreenElement && !document.msFullscreenElement ) {  // current working methods
    startFullscreen();
  } else {
    stopFullscreen();
  }
}

function startFullscreen() {
    if (document.documentElement.requestFullscreen) {
      document.documentElement.requestFullscreen();
    } else if (document.documentElement.msRequestFullscreen) {
      document.documentElement.msRequestFullscreen();
    } else if (document.documentElement.mozRequestFullScreen) {
      document.documentElement.mozRequestFullScreen();
    } else if (document.documentElement.webkitRequestFullscreen) {
      document.documentElement.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
    }
}
function stopFullscreen() {
    if (document.exitFullscreen) {
      document.exitFullscreen();
    } else if (document.msExitFullscreen) {
      document.msExitFullscreen();
    } else if (document.mozCancelFullScreen) {
      document.mozCancelFullScreen();
    } else if (document.webkitExitFullscreen) {
      document.webkitExitFullscreen();
    }  
}

function onWindowResize( event ) {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;

  //screenWidth = canvas.width;
  //screenHeight = canvas.height;
  //aspectX = canvas.width/canvas.height ;
  //aspectY = 1.0 ;

  gl.viewport( 0, 0, canvas.width, canvas.height );
}

function initWebGL( canvas ) {
  var gl = null;
  try {
    gl = canvas.getContext( "experimental-webgl" );
    gl.viewportWidth = canvas.width;
    gl.viewportHeight = canvas.height;
  } catch( e ) {
  }
  if( !gl ) {
    alert( "Unable to initialize WebGL" );
  }
  return gl;
}

function render( t ) {
  gl.clear( gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT );

  gl.uniform1f( timeUniform, t/1000 ); // frame ms time in t

  gl.bindBuffer( gl.ARRAY_BUFFER, quadBuffer );
  gl.vertexAttribPointer( vertexPositionAttribute, 3, gl.FLOAT, false, 0, 0 );

  gl.drawArrays( gl.TRIANGLE_STRIP, 0, 4 );
}

function initShaders() {
  var fragmentShader = getShader( gl, "shader-fs" );
  var vertexShader = getShader( gl, "shader-vs" );
  
  // Create the shader program
  shaderProgram = gl.createProgram();
  gl.attachShader( shaderProgram, vertexShader );
  gl.attachShader( shaderProgram, fragmentShader );
  gl.linkProgram( shaderProgram );
  
  // If creating the shader program failed, alert
  if( !gl.getProgramParameter( shaderProgram, gl.LINK_STATUS ) ) {
    alert( "Unable to initialize the shader program" );
  }
  
  gl.useProgram( shaderProgram );

  timeUniform = gl.getUniformLocation( shaderProgram, 't' );
  
  vertexPositionAttribute = gl.getAttribLocation( shaderProgram, "vert" );
  gl.enableVertexAttribArray( vertexPositionAttribute );
  
}

function shaderString( id ) {
  var scriptnode = document.getElementById( id );
  
  // Didn't find an element with the specified ID; abort.
  if( !scriptnode ) {
    return null;
  }
  
  // Walk through the source element's children, building the
  // shader source string.  
  var src = "";
  var p = scriptnode.firstChild;
  while( p ) {
    if( p.nodeType == 3 ) {
      src += p.textContent;
    }
    p = p.nextSibling;
  }
  return src;
}

function getShader( gl, id ) {
  var shaderScript = document.getElementById( id );
  
  // Didn't find an element with the specified ID; abort.
  if( !shaderScript ) {
    return null;
  }
  
  // Walk through the source element's children, building the
  // shader source string.  
  var theSource = "";
  var currentChild = shaderScript.firstChild;
  while( currentChild ) {
    if( currentChild.nodeType == 3 ) {
      theSource += currentChild.textContent;
    }
    currentChild = currentChild.nextSibling;
  }
  //console.log(theSource);
  // Construct shader according to script's MIME type
  var shader;
  if( shaderScript.type == "x-shader/x-fragment" ) {
    shader = gl.createShader( gl.FRAGMENT_SHADER );
  } else if( shaderScript.type == "x-shader/x-vertex" ) {
    shader = gl.createShader( gl.VERTEX_SHADER );
  } else {
    return null;  // Unknown shader type
  }
  
  gl.shaderSource( shader, theSource );
  gl.compileShader( shader );
  
  // Check for compile errors  
  if( !gl.getShaderParameter( shader, gl.COMPILE_STATUS ) ) {
    alert( "An error occurred compiling the shaders: " + gl.getShaderInfoLog( shader ) + "\n\nERROR: " + gl.getError()  );
    return null;
  }
  
  return shader;
}

function initBuffers() {
  var quad = [
     1.0,  1.0, 0.0,
    -1.0,  1.0, 0.0,
     1.0, -1.0, 0.0,
    -1.0, -1.0, 0.0
  ];
  quadBuffer = gl.createBuffer();
  gl.bindBuffer( gl.ARRAY_BUFFER, quadBuffer );
  gl.bufferData( gl.ARRAY_BUFFER, new Float32Array( quad ), gl.STATIC_DRAW );
}

</script>

<style type="text/css">
html, body {
  margin: 0px;
  overflow: hidden;
}
#glcanvas {
  width: 100%;
  height: 100%;
  background-color: white;
}
#editor {
  position: absolute;
  top: 0px;
  width: 40%;
  height: 95%;
  color: #99aa99;
  font-family: Monospace;
  font-size: 14px;
  font-weight: bold;
  text-shadow: rgba( 0, 0, 0, 0.75 ) 0px 1px 2px;
  background-color: rgba(0,0,0,0.2);
  padding: 1em;
  white-space: pre;
  overflow: scroll;
  outline: 0px solid transparent;
}

</style>

</head>

<body onload="start()">
  <div id="editor" contenteditable="true" spellcheck="false"></div>
  <canvas id="glcanvas" width="100%" height="100%">No HTML5 canvas support in the browser</canvas>
</body>

</html>
